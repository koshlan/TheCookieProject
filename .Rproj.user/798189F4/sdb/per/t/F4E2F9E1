{
    "contents" : "## FUNCTIONS ## \n\n#' converts character strings to numeric if possible\n#' \n#' For instance, convert: \"1 1/2 cups butter\" to 1.5\n#' \n#' @param string a charcter string\n#' @return a numeric value \n#' @example s <- \"2/3 cup (packed) golden brown sugar\n#' convert_ingredient_to_string_numeric(s)\nconvert_ingredient_to_string_numeric <- function(string){\n  string_handler <- function(s) {\n    if ( regexpr(\"/\", s) == 2) {\n      x = unlist(strsplit(s, split = \"/\"))\n      return( as.numeric(x[1]) / as.numeric(x[2]) )   \n    } else if ( suppressWarnings(!is.na(as.numeric(s)))) {\n      return(as.numeric(s))\n    } else {\n      return(0)\n    }\n  }\n  L = unlist(strsplit(string ,\" \"))\n  sum( sapply(L, string_handler))\n}\n\n#' extract common units\n#' \n#' For instance, extract \"cups\" from \"1 1/2 cups of flou\n#' \n#' @param string a character string\n#' @param patterns are string patterns of the units you want to detect\n#' @return a unit (the first detected pattern in patterns)\nextract_units<- function(string, patterns = c(\"cup\",\"tablespoon\",\"teaspoon\",\"cp\",\"tbs\",\"tsp\",\"stick\")){\n  a <- tolower(string)\n  unit = \"NA\"\n  for (p in patterns){\n    if(grepl(p, a, ignore.case = TRUE)){\n      unit = p\n      break\n    }\n  }\n  return(unit)\n}\n\n#' convert imperial volumetric units to metric volumetric units\n#' \n#' For instance, convert cups to mililiters\n#' \n#' @param vol\n#' @parum unit provide one of the following given unit c(\"cup\",\"tbs\",\"tsp\",\"tablespoon\", \"teaspoon\",\"stick\", \"NA\")\n#' @return volumetric converstion to mL\nimperial_to_metric <- function(vol, unit = c(\"cup\",\"tbs\",\"tsp\",\"tablespoon\", \"teaspoon\",\"stick\", \"NA\")){\n  if (is.null(unit)){\n    return(NULL)\n  }\n  unit <- match.arg(unit)\n  cup_to_ml <- 236\n  tbs_to_cup <- (1/16)\n  tsp_to_cup <- (1/48)\n  stick_to_ml <- 118\n  vol_ml <- switch(unit,\n                   \"cup\" =  vol * cup_to_ml,\n                   \"tbs\" =  vol * cup_to_ml * tbs_to_cup,\n                   \"tablespoon\" =  vol * cup_to_ml * tbs_to_cup,\n                   \"tsp\" =  vol * cup_to_ml * tsp_to_cup,\n                   \"teaspoon\" =  vol * cup_to_ml * tsp_to_cup,\n                   \"stick\" = vol * stick_to_ml,\n                   \n                   \"NA\" = 0 )\n  return(vol_ml)\n}\n\n#' Epicurious Specific Function (2015) for getting a list of ingredients\n#'\n#' This function was written for recipes at epicurious.com \n#' \n#' @param d a documented generated by htmlParse (see package XML)\n#' @return a list of ingredients, usually with the amounts proscribed by the \n#' recipe\nget_raw_ingredients <- function(d){\n  nodes <-getNodeSet(d,\"//ul[li[@class ='ingredient']]/li[@class ='ingredient']\")\n  return(sapply(nodes, xmlValue))\n}\n\n#' Epicurious Specific Function (2015) for getting user ratings \n#'\n#' This function was written for recipes at epicurious.com \n#' \n#' @param d a documented generated by htmlParse (see package XML)\n#' @return a numerical average user rating between 0 and 4\nget_average_rating <- function(d){\n  nodes <- getNodeSet(d,\"//div[@id = 'fork_rating']/meta[@itemprop = 'ratingValue']/@content\")\n  return(as.numeric(as.character(nodes[[1]])))\n}\n\n#' Epicurious Specific Function (2015) for getting the magazine source of a recipe\n#' \n#' This function was written for recipes at epicurious.com \n#' \n#' @param d a documented generated by htmlParse (see package XML)\n#' @return a character string like \"Gourmet Magazine\" \nget_magazine <- function(d){\n  #nodes <- getNodeSet(d,\"//div[@id = 'headline']/div[@class = 'source-container']/p[@id = 'mag_info']/a[@itemprop='publisher']\")\n  nodes <- getNodeSet(d,\"//a[@itemprop='publisher']\")\n  return(xmlValue(nodes[[1]]))\n}\n\n#' Epicurious Specific Function (2015) for getting the magazine source of a recipe\n#' \n#' This function was written for recipes at epicurious.com \n#' \n#' @param d a documented generated by htmlParse (see package XML)\n#' @return a character string containing the date of recipe publication\nget_date <- function(d){\n  nodes <- getNodeSet(d,\"//p[@id = 'mag_info']\")\n  return(xmlValue(nodes[[1]] ) )\n}\n\n#' Epicurious Specific Function (2015) for processing list of ingredients\n#' \n#' This function was written for recipes at epicurious.com \n#' \n#' @param recipe a list of ingredients generated by get_raw_ingredients()\n#' @return a list containing the (i) volumes of each ingredient in mL,\n#' (ii) the percentage of each volumetrically, (iii) the raw ingredient strings\nprocess_recipe <- function(recipe){\n  tt <- list( units = unlist(sapply(recipe, extract_units)),\n              volume  = sapply(recipe, convert_ingredient_to_string_numeric))\n  amt_ml = c()\n  for (i in 1:length(tt$units)){\n    amt_ml[i] <- imperial_to_metric(tt$volume[i], tt$units[i])\n  }\n  tt[[\"vol_ml\"]] <- amt_ml\n  tt[['percent_volume']] <- amt_ml / sum(amt_ml)\n  tt[['raw']] <- recipe\n  return(tt)\n}\n\n\n#' Given an ingredient return its volumetric percentage\n#' \n#' @param r\n#' @return percentage (volumetric basis) of the ingredient\npercentage_ingredient <- function(r , ingredient = \"butter\") {\n  ingredient_boolean = sapply(r$raw , function(x) { exist_ingredient(ingredient = ingredient, test_string = x) } )\n  percentage <- sum(r$percent_volume[ ingredient_boolean ] )\n  return(percentage)\n}\n\n\n#' Test if an infredient exists\n#' \n#' @param ingredient is a string such as \"chocolate\" or \"butter\"\n#' @param test_string is a string which will be tested for the specified\nexist_ingredient <- function(ingredient = \"chocolate\" , test_string = NULL ){\n  if (is.null(test_string)){\n    stop(\" Must provide a test_string\")\n  }\n  grepl(ingredient, test_string,ignore.case = TRUE)\n}\n\n\n\n\n\n\n\n#### FUNCTIONAL CODE ##### \n\n## BLOCK OF CODE FOR GETTING LINKS ##\n# script for individual epicurious recipe pages\n# get_links <- function(url){\n#   doc <- htmlParse(url)\n#   m <- getNodeSet(doc, \"//a[contains(.,'Cookies')]/@href\") #[ ] [contains(., 'Ingredients')]/ul\")[[1]]\n#   links <- sapply(m, as.character)\n#   return(links)\n#   \n# }\n# \n# primary_url = \"http://www.epicurious.com/tools/searchresults?search=chocolate+chip+cookies\"\n# index_link = \"epi_index.html\" \n# \n# url <- c(\"http://www.epicurious.com/tools/searchresults?search=chocolate+chip+cookies\",\n#          \"http://www.epicurious.com/tools/searchresults?search=chocolate+chip+cookies&pageNumber=2&pageSize=20&resultOffset=21\",\n#          \"http://www.epicurious.com/tools/searchresults?search=chocolate+chip+cookies&pageNumber=3&pageSize=20&resultOffset=41\",\n#          \"http://www.epicurious.com/tools/searchresults?search=chocolate+chip+cookies&pageNumber=4&pageSize=20&resultOffset=61\",\n#          \"http://www.epicurious.com/tools/searchresults?search=chocolate+chip+cookies&pageNumber=5&pageSize=20&resultOffset=81\")\n# \n# links = list()\n# for (u in url){\n#   links[[u]]<-get_links(u)\n#   noise = rnorm(1)\n#   wait_for = 5 + noise + noise\n#   if (wait_for < 0 ){\n#     wait_for <- 2\n#   }\n#   Sys.sleep(wait_for)\n# }\n\n\n#saveRDS(links, \"links.rds\")\nlinks = readRDS(\"links.rds\")\nlist_of_links <- unlist(links)\n\n##BLOCK OF CODE OPERATING ON THOSE LINKS\n# cookies_list = list()\n# count =  0\n# for (l in list_of_links){\n#   try({\n#     l <- paste(\"http://www.epicurious.com\", l, sep = \"\")\n#     count = count + 1 \n#     d <- htmlParse(l)\n#     saveXML(d, paste(as.character(count),\".html\", sep = \"\")  )\n#     ingredient_list <- get_raw_ingredients(d)\n#     rating <- get_average_rating(d)\n#     magazine <- get_magazine(d)\n#     date <- get_date(d)\n#     cookies_list[[l]][['ingredients']] <- ingredient_list\n#     cookies_list[[l]][['process']] <- process_recipe(ingredient_list)\n#     cookies_list[[l]][['rating']] <- rating\n#     cookies_list[[l]][['magazine']] <- magazine\n#     cookies_list[[l]][['date']] <- date\n#   })\n#   noise = rnorm(1)\n#   wait_for = 3 + 3*noise + 2*noise\n#   if (wait_for < 0 ){\n#     wait_for <- 2\n#   }\n#   Sys.sleep(wait_for)\n# }\n# #saveRDS(cookies_list, \"epicurious_top.rds\")\ncookies_list <- readRDS(\"epicurious_top.rds\")\n\n\n### BLOCK TO CREATE DATAFRAME ### \npr <- lapply(cookies_list, function(x) x$process)\ndf = data.frame(butter = rep(1,length(pr)))\nfor (ingredient in c(\"butter\",\"oats\",\"flour\",\"sugar\",\"honey\",\"syrup\",\"chocolate\")){\n  df[[ingredient]] <- sapply(pr, function(x) percentage_ingredient(x, ingredient ) )\n}\nmagazines <- sapply(cookies_list, function(x) x$magazine)\ndates <- sapply(cookies_list, function(x) x$date)\nratings <-sapply(cookies_list, function(x) x$rating)\ndf$magazine <- magazines\ndf$date <- dates\ndf$rating <- ratings\ndf$rating <- sapply(ratings, function(x) 5^x)\nrownames(df) <- names(pr)\n\nlibrary(ggplot2)\nggplot(df, aes(x=butter,y=sugar, colour = magazine, size= rating)) + geom_point()\nggplot(df, aes(x=butter,y=rating, colour = magazine, size= rating)) + geom_point()\n\n\n\n\n\n\n\n\n\n",
    "created" : 1428909281609.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2735062612",
    "id" : "F4E2F9E1",
    "lastKnownWriteTime" : 1428909290,
    "path" : "~/Documents/TheCookieProject/epicurious.r",
    "project_path" : "epicurious.r",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}