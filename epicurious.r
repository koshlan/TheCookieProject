## FUNCTIONS ## 

#' converts character strings to numeric if possible
#' 
#' For instance, convert: "1 1/2 cups butter" to 1.5
#' 
#' @param string a charcter string
#' @return a numeric value 
#' @example s <- "2/3 cup (packed) golden brown sugar
#' convert_ingredient_to_string_numeric(s)
convert_ingredient_to_string_numeric <- function(string){
  string_handler <- function(s) {
    if ( regexpr("/", s) == 2) {
      x = unlist(strsplit(s, split = "/"))
      return( as.numeric(x[1]) / as.numeric(x[2]) )   
    } else if ( suppressWarnings(!is.na(as.numeric(s)))) {
      return(as.numeric(s))
    } else {
      return(0)
    }
  }
  L = unlist(strsplit(string ," "))
  sum( sapply(L, string_handler))
}

#' extract common units
#' 
#' For instance, extract "cups" from "1 1/2 cups of flou
#' 
#' @param string a character string
#' @param patterns are string patterns of the units you want to detect
#' @return a unit (the first detected pattern in patterns)
extract_units<- function(string, patterns = c("cup","tablespoon","teaspoon","cp","tbs","tsp","stick")){
  a <- tolower(string)
  unit = "NA"
  for (p in patterns){
    if(grepl(p, a, ignore.case = TRUE)){
      unit = p
      break
    }
  }
  return(unit)
}

#' convert imperial volumetric units to metric volumetric units
#' 
#' For instance, convert cups to mililiters
#' 
#' @param vol
#' @parum unit provide one of the following given unit c("cup","tbs","tsp","tablespoon", "teaspoon","stick", "NA")
#' @return volumetric converstion to mL
imperial_to_metric <- function(vol, unit = c("cup","tbs","tsp","tablespoon", "teaspoon","stick", "NA")){
  if (is.null(unit)){
    return(NULL)
  }
  unit <- match.arg(unit)
  cup_to_ml <- 236
  tbs_to_cup <- (1/16)
  tsp_to_cup <- (1/48)
  stick_to_ml <- 118
  vol_ml <- switch(unit,
                   "cup" =  vol * cup_to_ml,
                   "tbs" =  vol * cup_to_ml * tbs_to_cup,
                   "tablespoon" =  vol * cup_to_ml * tbs_to_cup,
                   "tsp" =  vol * cup_to_ml * tsp_to_cup,
                   "teaspoon" =  vol * cup_to_ml * tsp_to_cup,
                   "stick" = vol * stick_to_ml,
                   
                   "NA" = 0 )
  return(vol_ml)
}

#' Epicurious Specific Function (2015) for getting a list of ingredients
#'
#' This function was written for recipes at epicurious.com 
#' 
#' @param d a documented generated by htmlParse (see package XML)
#' @return a list of ingredients, usually with the amounts proscribed by the 
#' recipe
get_raw_ingredients <- function(d){
  nodes <-getNodeSet(d,"//ul[li[@class ='ingredient']]/li[@class ='ingredient']")
  return(sapply(nodes, xmlValue))
}

#' Epicurious Specific Function (2015) for getting user ratings 
#'
#' This function was written for recipes at epicurious.com 
#' 
#' @param d a documented generated by htmlParse (see package XML)
#' @return a numerical average user rating between 0 and 4
get_average_rating <- function(d){
  nodes <- getNodeSet(d,"//div[@id = 'fork_rating']/meta[@itemprop = 'ratingValue']/@content")
  return(as.numeric(as.character(nodes[[1]])))
}

#' Epicurious Specific Function (2015) for getting the magazine source of a recipe
#' 
#' This function was written for recipes at epicurious.com 
#' 
#' @param d a documented generated by htmlParse (see package XML)
#' @return a character string like "Gourmet Magazine" 
get_magazine <- function(d){
  #nodes <- getNodeSet(d,"//div[@id = 'headline']/div[@class = 'source-container']/p[@id = 'mag_info']/a[@itemprop='publisher']")
  nodes <- getNodeSet(d,"//a[@itemprop='publisher']")
  return(xmlValue(nodes[[1]]))
}

#' Epicurious Specific Function (2015) for getting the magazine source of a recipe
#' 
#' This function was written for recipes at epicurious.com 
#' 
#' @param d a documented generated by htmlParse (see package XML)
#' @return a character string containing the date of recipe publication
get_date <- function(d){
  nodes <- getNodeSet(d,"//p[@id = 'mag_info']")
  return(xmlValue(nodes[[1]] ) )
}

#' Epicurious Specific Function (2015) for processing list of ingredients
#' 
#' This function was written for recipes at epicurious.com 
#' 
#' @param recipe a list of ingredients generated by get_raw_ingredients()
#' @return a list containing the (i) volumes of each ingredient in mL,
#' (ii) the percentage of each volumetrically, (iii) the raw ingredient strings
process_recipe <- function(recipe){
  tt <- list( units = unlist(sapply(recipe, extract_units)),
              volume  = sapply(recipe, convert_ingredient_to_string_numeric))
  amt_ml = c()
  for (i in 1:length(tt$units)){
    amt_ml[i] <- imperial_to_metric(tt$volume[i], tt$units[i])
  }
  tt[["vol_ml"]] <- amt_ml
  tt[['percent_volume']] <- amt_ml / sum(amt_ml)
  tt[['raw']] <- recipe
  return(tt)
}


#' Given an ingredient return its volumetric percentage
#' 
#' @param r
#' @return percentage (volumetric basis) of the ingredient
percentage_ingredient <- function(r , ingredient = "butter") {
  ingredient_boolean = sapply(r$raw , function(x) { exist_ingredient(ingredient = ingredient, test_string = x) } )
  percentage <- sum(r$percent_volume[ ingredient_boolean ] )
  return(percentage)
}


#' Test if an infredient exists
#' 
#' @param ingredient is a string such as "chocolate" or "butter"
#' @param test_string is a string which will be tested for the specified
exist_ingredient <- function(ingredient = "chocolate" , test_string = NULL ){
  if (is.null(test_string)){
    stop(" Must provide a test_string")
  }
  grepl(ingredient, test_string,ignore.case = TRUE)
}







#### FUNCTIONAL CODE ##### 

## BLOCK OF CODE FOR GETTING LINKS ##
# script for individual epicurious recipe pages
# get_links <- function(url){
#   doc <- htmlParse(url)
#   m <- getNodeSet(doc, "//a[contains(.,'Cookies')]/@href") #[ ] [contains(., 'Ingredients')]/ul")[[1]]
#   links <- sapply(m, as.character)
#   return(links)
#   
# }
# 
# primary_url = "http://www.epicurious.com/tools/searchresults?search=chocolate+chip+cookies"
# index_link = "epi_index.html" 
# 
# url <- c("http://www.epicurious.com/tools/searchresults?search=chocolate+chip+cookies",
#          "http://www.epicurious.com/tools/searchresults?search=chocolate+chip+cookies&pageNumber=2&pageSize=20&resultOffset=21",
#          "http://www.epicurious.com/tools/searchresults?search=chocolate+chip+cookies&pageNumber=3&pageSize=20&resultOffset=41",
#          "http://www.epicurious.com/tools/searchresults?search=chocolate+chip+cookies&pageNumber=4&pageSize=20&resultOffset=61",
#          "http://www.epicurious.com/tools/searchresults?search=chocolate+chip+cookies&pageNumber=5&pageSize=20&resultOffset=81")
# 
# links = list()
# for (u in url){
#   links[[u]]<-get_links(u)
#   noise = rnorm(1)
#   wait_for = 5 + noise + noise
#   if (wait_for < 0 ){
#     wait_for <- 2
#   }
#   Sys.sleep(wait_for)
# }


#saveRDS(links, "links.rds")
links = readRDS("links.rds")
list_of_links <- unlist(links)

##BLOCK OF CODE OPERATING ON THOSE LINKS
# cookies_list = list()
# count =  0
# for (l in list_of_links){
#   try({
#     l <- paste("http://www.epicurious.com", l, sep = "")
#     count = count + 1 
#     d <- htmlParse(l)
#     saveXML(d, paste(as.character(count),".html", sep = "")  )
#     ingredient_list <- get_raw_ingredients(d)
#     rating <- get_average_rating(d)
#     magazine <- get_magazine(d)
#     date <- get_date(d)
#     cookies_list[[l]][['ingredients']] <- ingredient_list
#     cookies_list[[l]][['process']] <- process_recipe(ingredient_list)
#     cookies_list[[l]][['rating']] <- rating
#     cookies_list[[l]][['magazine']] <- magazine
#     cookies_list[[l]][['date']] <- date
#   })
#   noise = rnorm(1)
#   wait_for = 3 + 3*noise + 2*noise
#   if (wait_for < 0 ){
#     wait_for <- 2
#   }
#   Sys.sleep(wait_for)
# }
# #saveRDS(cookies_list, "epicurious_top.rds")
cookies_list <- readRDS("epicurious_top.rds")


### BLOCK TO CREATE DATAFRAME ### 
pr <- lapply(cookies_list, function(x) x$process)
df = data.frame(butter = rep(1,length(pr)))
for (ingredient in c("butter","oats","flour","sugar","honey","syrup","chocolate")){
  df[[ingredient]] <- sapply(pr, function(x) percentage_ingredient(x, ingredient ) )
}
magazines <- sapply(cookies_list, function(x) x$magazine)
dates <- sapply(cookies_list, function(x) x$date)
ratings <-sapply(cookies_list, function(x) x$rating)
df$magazine <- magazines
df$date <- dates
df$rating <- ratings
df$rating <- sapply(ratings, function(x) 5^x)
rownames(df) <- names(pr)

library(ggplot2)
ggplot(df, aes(x=butter,y=sugar, colour = magazine, size= rating)) + geom_point()
ggplot(df, aes(x=butter,y=rating, colour = magazine, size= rating)) + geom_point()









